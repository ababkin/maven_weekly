runStderrLoggingT $ withPostgresqlConn connStr $ \conn -> do
  liftIO $ flip runSqlPersistM conn $ do 
    -- Do database Stuff

-- Ok lets try to understand what's happening. First lets check out the types.

runStderrLoggingT :: MonadIO m => LoggingT m a -> m a
-- Give this guy some sort logger monad transformer and he'll give us back our monad. Easy enough.

withPostgresqlConn :: (MonadIO m, MonadBaseControl IO m, MonadLogger m) => ConnectionString -> (SqlBackend -> m a) -> m a
-- Looks like we give this function some connection information,
-- and a function that uses that connection information to return another monad. Then we get that monad back at the end.
-- This makes sense, internally this function does the dirty work of creating 
-- a database connection, and then we're able to use that connection because it will 
-- be passed as an argument to the function we pass in.(See `conn` variable on line 1). 
-- Now we can use that connection to do whatever database work we want(inserting data, querying etc etc)

runSqlPersistM :: SqlPersistM a -> SqlBackend -> IO a

-- Ah now we're down to where we can actually do work.
-- Lets look at the flipped version since that's how it's being used above
let flippedRunSqlPersistM = flip runSqlPersistM
flippedRunSqlPersistM :: SqlBackend -> SqlPersistM a -> IO a

-- Ok well it looks like this function takes a database connection(SqlBackend)
-- some sort of SqlPersistM type and does some IO(hint: database queries, inserts, etc)
-- Sweet, that's not too bad. Lets check out what the SqlPersistM type looks like:

type SqlPersistM = SqlPersistT (NoLoggingT (ResourceT IO))
-- Hmm ok, don't really know what any of that stuff is. What does SqlPersistT, NoLoggingT and ResourceT do?

type SqlPersistT = ReaderT SqlBackend
-- Aha! Finally down to a monad transformer I understand!
-- So we have a ReaderT transformer where the "environment" value is our database connection. 
-- This makes total sense because now our functions that actually do database work e.g:
insert :: (MonadIO m, backend ~ PersistEntityBackend val, PersistEntity val) => val -> ReaderT backend m (Key val)
update :: (MonadIO m, PersistEntity val, backend ~ PersistEntityBackend val) => Key val -> [Update val] -> ReaderT backend m ()
-- can utilize this connection! 

-- Ok now what are all the other transformers for?
-- Since SqlPersistT is really just an alias to ReaderT, lets replace that in our alias for SqlPeristM.
type SqlPersistM = ReaderT SqlBackend (NoLoggingT (ResourceT IO))

-- This is star

newtype NoLoggingT m a = NoLoggingT { runNoLoggingT :: m a }
newtype ReaderT SqlBackend (NoLoggingT (ResourceT IO)) a :: * -> (* -> *) -> * -> *
newtype ResourceT m a = ResourceT { unResourceT :: I.IORef ReleaseMap -> m a }

